============================
Natural Language Programming
============================

Using the Ring programming language, we can create Natural programming languages based
on classes and objects.

History
=======

In 2010, I developed a new programming language called Supernova (developed using PWCT).
This language uses a code that looks similar to Natural Language statements to create simple GUI applications.
Now after five years, In the Ring programming language, we can get similar results, but now we have the ability 
to create/use code similar to Natural language statements in any domain that we like or need.

The Ring programming language comes with the Supernova sprite, but with more generalization and with mix of other languages
sprites.

Example
=======

The next example presents how to create a class that define two instructions 

The first instruction is : I want window

The second instruction is : Window title = <expr>

Also keywords that can be ignored like the 'the' keyword

.. code-block:: none

	New App 
	{
		I want window 	
		The window title = "hello world"
	}

	Class App

		# Attributes for the instruction I want window
			i want window 
			nIwantwindow = 0
		# Attributes for the instruction Window title
		# Here we don't define the window attribute again
			title 
			nWindowTitle = 0
		# Keywords to ignore, just give them any value
			the=0	

		func geti
			if nIwantwindow = 0
				nIwantwindow++
			ok

		func getwant
			if nIwantwindow = 1
				nIwantwindow++
			ok

		func getwindow
			if nIwantwindow = 2
				nIwantwindow= 0
				see "Instruction : I want window" + nl
			ok
			if nWindowTitle = 0
				nWindowTitle++
			ok
	
		func settitle cValue
			if nWindowTitle = 1
				nWindowTitle=0
				see "Instruction : Window Title = " + cValue + nl
			ok
		

Output:

.. code-block:: none

	Instruction : I want window
	Instruction : Window Title = hello world


Change the Ring Keyword 'And'
=============================

What if we want to connect between the two instructions using 'and'

We have a problem because in Ring 'and' is a keyword

We can change that using the ChangeRingKeyword command.

Syntax:

.. code-block:: none
	
	ChangeRingKeyword  <oldkeyword>  <newkeyword>

.. note:: remember to restore the keyword again 

.. tip:: The ChangeRingKeyword command is executed in the scanner stage by the compiler (before parsing).
	
Example:

.. code-block:: none

	ChangeRingKeyword	and  _and

	New App
	{
			I want window and the window title = "hello world"
	}

	Class App

			# Attributes for the instruction I want window
					i want window
					nIwantwindow = 0
			# Attributes for the instruction Window title
			# Here we don't define the window attribute again
					title
					nWindowTitle = 0
			# Keywords to ignore, just give them any value
					the=0  and=0

	ChangeRingKeyword	_and  and

			func geti
					if nIwantwindow = 0
							nIwantwindow++
					ok

			func getwant
					if nIwantwindow = 1
							nIwantwindow++
					ok

			func getwindow
					if nIwantwindow = 2
							nIwantwindow= 0
							see "Instruction : I want window" + nl
					ok
					if nWindowTitle = 0
							nWindowTitle++
					ok

			func settitle cValue
					if nWindowTitle = 1
							nWindowTitle=0
							see "Instruction : Window Title = " + cValue + nl
					ok

		func getand
			see "Using : and" + nl

Output:

.. code-block:: none

	Instruction : I want window
	Using : and
	Instruction : Window Title = hello world
			
		
BraceStart and BraceEnd Methods
===============================

We can write code that will be executed before/after using { }

Example:

.. code-block:: none

	o1 = new test {
		see "Hello" + nl
	}

	o1 {}

	class test

		func bracestart
			see "start" + nl

		func braceend
			see "end" + nl

Output:

.. code-block:: none

	start
	Hello
	end
	start
	end


BraceExprEval Method
====================

The next example demonstrates how to use the "BraceExprEval" method to get expressions in
Natural code.

Example:

.. code-block:: none

	new natural {
		create 5
	}

	class natural
		create=0
		lkeyword = false
		func braceexpreval r		
			if lkeyword lkeyword=false return ok
			see "expr eval" + nl
			see "type: " + type(r) see nl
			see "value : " see r see nl
		func getcreate
			lkeyword = true
			see "create" + nl

Output:

.. code-block:: none

	create
	expr eval
	type: NUMBER
	value : 5

Real Natural Code
=================

The next example is a more advanced example 

.. code-block:: none

	# Natural Code
	new program {
		get 2 numbers then print the sum
	}

	# Natural Code Implementation
	class program
		# Keywords
			get=0 numbers=0 then=0 print=0 the=0 sum=0

		# Execution
		func braceexpreval x
			value = x
		func getnumbers
			for x=1 to value
				see "Enter Number ("+x+") :" give nNumber
				aNumbers + nNumber
			next
		func getsum
			nSUm = 0
			for x in aNumbers nSum+= x next
			see "The Sum : " + nSum
		private
			value=0	aNumbers=[]
		
Output: 

.. code-block:: none

	Enter Number (1) :3
	Enter Number (2) :4
	The Sum : 7

