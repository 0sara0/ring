.. index:: 
	single: Language Design; Introduction

===============
Language Design
===============

In this chapter we will learn about the basic concepts behind the language design.

.. index:: 
	pair: Language Design; Why Ring?

Why Ring?
=========

The language is simple, trying to be natural, encourage organization and comes 
with transparent and visual implementation. It comes with compact syntax and a
group of features that enable the programmer to create natural interfaces and
declarative domain-specific languages in a fraction of time. It is very small,
fast and comes with smart garbage collector that puts the memory under the 
programmer control. It supports many programming paradigms, comes with useful 
and practical libraries. The language is designed for productivity and developing
high quality solutions that can scale.

.. index:: 
	pair: Language Design; Designed for a clear goal

Designed for a Clear Goal
=========================

* Applications programming language.
* Productivity and developing high quality solutions that can scale.
* Small and fast language that can be embedded in C/C++ projects.
* Simple language that can be used in education and introducing Compiler/VM concepts.
* General-Purpose language that can be used for creating domain-specific libraries, frameworks and tools.
* Practical language designed for creating the next version of the Programming Without Coding Technology software.

.. index:: 
	pair: Language Design; Simple

Simple
======

Ring is a very simple language, and has a very straightforward syntax. It encourages programmers to program without boilerplate code

.. code-block:: ring

	See "Hello, World!" 

The Main function is optional and will be executed after the statements, and is useful for using the local scope.

.. code-block:: ring

	Func Main
		See "Hello, World!" 
		
Uses Dynamic Typing and Lexical scoping. No $ is required before the variable name! 
You can use the '+' operator for string concatenation and the language is weakly typed and will convert automatically between numbers and strings based on the context.

.. code-block:: ring

	nCount = 10	# Global variable
	Func Main
		nID = 1	# Local variable
		See "Count = " + nCount + nl + " ID = " + nID

.. index:: 
	pair: Language Design; Trying to be natural

Trying to be natural
====================

Ring is not case-sensitive

.. code-block:: ring


	See "Enter your name ? " 
	Give name
	See "Hello " + Name	# Name is the same as name 
			
The list index starts from 1

.. code-block:: ring

	aList = ["one","two","three"]
	See aList[1]	# print one
			
Call functions before definition

.. code-block:: ring


	one() 
	two() 
	three()
	Func one 
		See "One" + nl
	Func two 
		See "two" + nl
	Func three 
		See "three" + nl
			
The assignment operator uses Deep copy (no references in this operation)

.. code-block:: ring

	aList = ["one","two","three"]
	aList2 = aList
	aList[1] = 1
	see alist[1]	# print 1
	see aList2[1]	# print one
				
Pass numbers and strings by value, but pass lists and objects by reference. 
The for in loop can update the list items.

.. code-block:: ring

	Func Main
		aList = [1,2,3]
		update(aList)
		see aList	# print one two three

	Func update aList
		for x in aList
			switch x
			on 1 x = "one"
			on 2 x = "two"
			on 3 x = "three"
			off
		next
			
Using Lists during definition

.. code-block:: ring

	aList = [ [1,2,3,4,5] , aList[1] , aList[1] ]
	see aList       # print 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
			
Exit from more than one loop

.. code-block:: ring

	for x = 1 to 10
			for y = 1 to 10
					see "x=" + x + " y=" + y + nl
					if x = 3 and y = 5
							exit 2     # exit from 2 loops
					ok
			next
	next
	
.. index:: 
	pair: Language Design; Encourage Organization

Encourage Organization
======================

The language encourage organization, Forget bad days using languages where the programmer start with function then class then function and a strange mix between things! 

Each source file follow the next structure 

* Load Files
* Statements and Global Variables
* Functions
* Packages and Classes

This enable us to use Packages, Classes and Functions without the need to use a keyword to end these components. 

We can write one line comments and multi-line comments 
The comment starts with # or // 
Multi-line comments are written between /* and */

.. code-block:: ring

	/* 
		Program Name : My first program using Ring
		Date         : 2015.05.08
	*/

	See "What is your name? " 	# print message on screen
	give cName 			# get input from the user
	see "Hello " + cName		# say hello!

	// See "Bye!"
				

.. index:: 
	pair: Language Design; Compact Syntax

Compact Syntax
==============

The language is not line sensitive, you don't need to write ; after statements, also you don't need to press ENTER or TAB, so we can write the next code

.. code-block:: ring


	See "The First Message"	See " Another message in the same line! " + nl
	See "Enter your name?" Give Name See "Hello " + Name
			
The next code create a class called Point contains three attributes X,Y and Z. No keywords is used to end the package/class/function definition. Also, we can write the attributes names directly below the class name.

.. code-block:: ring

	Class Point X Y Z
			
We can use classes and functions before their definition, In this example we will create new object, set the object attributes then print the object values.

.. code-block:: ring

	o1 = New point	o1.x=10    o1.y=20   o1.z=30	See O1	Class Point X Y Z
			
Instead of using the dot '.' operator to access the object attributes and methods we can use braces { } to access the object, then we can use the object attributes and methods.

.. code-block:: ring

	o1 = New point { x=10 y=20 z=30 } See O1  Class Point X Y Z
			 
Now we will call a method after accessing the object using { }

.. code-block:: ring

	 
	oPerson = new Person
	{
		Name = "Somebody"
		Address = "Somewhere"
		Phone = "0000000"
		Print()			# here we call the Print() method
	}
	Class Person Name Address Phone
		Func Print
			See "Name :" + name + nl +
				"Address :" + Address + nl +
				"Phone : " + phone + nl

When we use { } to access the object then write any attribute name, the language will check the class for any setter/getter methods that will be called automatically.

.. code-block:: ring


	New Number {
			See one		# Execute GetOne()
			See two		# Execute GetTwo()
			See three	# Execute GetThree()
	}
	Class Number one two three
		Func GetOne
			See "Number : One" + nl
			return 1
		Func GetTwo
			See "Number : Two" + nl
			return 2
		Func GetThree
			See "Number : Three" + nl
			return 3	
			
.. index:: 
	pair: Language Design; Define Natural Statements

Define Natural Statements
=========================

After the object access using { } if the class contains a method called BraceEnd() it will be executed!

.. code-block:: ring


	TimeForFun = new journey
	# The first surprise!
	TimeForFun {
		Hello it is me		# What a beatiful programming world!
	}
	# Our Class
	Class journey
		hello=0 it=0 is=0 me=0
		func GetHello
			See "Hello" + nl
		func braceEnd
			See "Goodbye!" + nl

We can execute code written in strings using the Eval() function

.. code-block:: ring


	cCode = "See 'Code that will be executed later!' "
	Eval(cCode)	# execute the code to print the message

We can create a list then execute code generated from that list

.. code-block:: ring

	aWords = ["hello","it","is","me"]
	for word in aWords cCode=word+"=0" eval(cCode) next

We can read text files using the Read(cFileName) function and we can write files using the Write(cFileName,cString) function.

.. code-block:: ring

	See "Enter File Name:" Give cFileName See Read(cFileName) # Print the file content

The next example presents how to create a class that defines two instructions
The first instruction is : I want window
The second instruction is : Window title = Expression 
Also keywords that can be ignored like the ‘the’ keyword 

.. code-block:: ring


	New App
	{
		I want window
		The window title = "hello world"
	}

	Class App

		# Attributes for the instruction I want window
			i want window
			nIwantwindow = 0
		# Attributes for the instruction Window title
		# Here we don't define the window attribute again
			title
			nWindowTitle = 0
		# Keywords to ignore, just give them any value
			the=0

		func geti
				if nIwantwindow = 0
					nIwantwindow++
				ok

		func getwant
				if nIwantwindow = 1
					nIwantwindow++
				ok

		func getwindow
				if nIwantwindow = 2
					nIwantwindow= 0
					see "Instruction : I want window" + nl
				ok
				if nWindowTitle = 0
					nWindowTitle++
				ok

		func settitle cValue
				if nWindowTitle = 1
					nWindowTitle=0
					see "Instruction : Window Title = " + cValue + nl
				ok

		
To complete the previous example, use read() to get the content of a file that contains

.. code-block:: ring

	I want window
	The window title = "hello world"

Then use eval() to execute the content of that file!.
Also, you can update the methods GetWindow() and SetTitle() to create Real windows using the GUI Library


.. index:: 
	pair: Language Design; Define Declarative Languages

Define Declarative Languages
============================


We learned how to use Natural statements to execute our code and using the same features we can use nested structures to execute our code.

The next example from the Web library, generate HTML document using the Bootstrap library. No HTML code is written directly in this example, we created a similar language (just as example) Then using this declarative language that uses nested structures, we generated the HTML Document.. 
The idea in this example is that the GetDiv() and GetH1() methods return an object that we can access using {} and after each object access the method BraceEnd() will be executed to send the generated HTML to the parent object until we reach to the root where BraceEnd() will print the output.

.. code-block:: ring

	Load "weblib.ring"
	Import System.Web

	Func Main

	  BootStrapWebPage()
	  {
		div
		{
		  classname = :container
		  div
		  {
			classname = :jumbotron
			H1 {   text("Bootstrap Page")   }
		  }
		  div
		  {
			classname = :row
			for x = 1 to 3
			  div
			  {
			    classname = "col-sm-4"
			    H3 { html("Welcome to the Ring programming language") }
			    P  { html("Using a scripting language is very fun!") }
			  }
			next
		  }
		}
	  }

The classes that power the declarative interface looks like this

.. code-block:: ring

	Class Link from ObjsBase
		title  link
		Func braceend			
			cOutput = nl+GetTabs() + "<a href='" + 
				  Link + "'> "+ Title + " </a> " + nl			

	Class Div from ObjsBase 
		Func braceend
			cOutput += nl+'<div'
			addattributes()
			AddStyle()
			getobjsdata()
			cOutput += nl+"</div>" + nl
			cOutput = TabMLString(cOutput)

.. index:: 
	pair: Language Design; Syntax Flexibility

Syntax Flexibility
==================

Ring comes with many styles for writing your source code!

Also you can change the language keywords and operators and create your custom style!

	 
.. index:: 
	pair: Language Design; Transparent Implementation

Transparent Implementation
==========================

Ring comes with transparent implementation. We can know what is happening in each compiler stage and what is going on during the run-time by the Virtual Machine Example : ring helloworld.ring -tokens -rules -ic

.. code-block:: ring

	See "Hello, World!" 
			
Output

.. code-block:: ring


	==================================================================
	Tokens - Generated by the Scanner
	==================================================================

	   Keyword : SEE
	   Literal : Hello, World!
	   EndLine

	==================================================================

	==================================================================
	Grammar Rules Used by The Parser
	==================================================================

	Rule : Program --> {Statement}

	Line 1
	Rule : Factor --> Literal
	Rule : Range --> Factor
	Rule : Term --> Range
	Rule : Arithmetic --> Term
	Rule : BitShift --> Arithmetic
	Rule : BitAnd --> BitShift
	Rule : BitOrXOR -->  BitAnd
	Rule : Compare --> BitOrXOR
	Rule : EqualOrNot --> Compare
	Rule : LogicNot -> EqualOrNot
	Rule : Expr --> LogicNot
	Rule : Statement  --> 'See' Expr

	==================================================================



	==================================================================
	Byte Code - Before Execution by the VM
	==================================================================

		 PC      OPCode        Data

		  1     FuncExE
		  2       PushC   Hello, World!
		  3       Print
		  4  ReturnNull

	==================================================================

	Hello, World!
				
.. index:: 
	pair: Language Design; Visual Implementation

Visual Implementation
=====================

The Ring programming language is designed using the PWCT visual programming tool 
and you will find the visual source of the language in the folder "visualsrc" - *.ssf 
files and the generated source code (In the C Language) in the	src folder and 
the include folder.

The next screen shot from the ring_vm.ssf file (Generate ring_vm.c and ring_vm.h) 

.. image:: visualsrc1.jpg

The next screen shot from the ring_list.ssf file (Generate ring_list.c and ring_list.h) 

.. image:: visualsrc2.JPG

.. index:: 
	pair: Language Design; Smart Garbage Collector

Smart Garbage Collector
=======================

Avoid memory problems :- 

* Invalid Memory Access
* Memory leaks
* Uninitialized Memory Access
* Dangling pointer

Rules :- 

* Global variables always stay in the memory, until you delete these variables using the assignment statement.
* Local variables always deleted after the end of the function.
* The programmer have full control on when to delete the variable from the memory using the Assignment statement.

Example:

.. code-block:: ring

	aList = [1,2,3,4,5]
	aList = "nice"
			
After the second line directly, The list [1,2,3,4,5] will be deleted from the memory and we will have a string "nice" 

* The programmer can call the function callgc() to force running the garbage collector.
* If we have a reference to a variable (when we pass objects and lists to functions), then deleting variables will be based on reference counting, if no references everything will be deleted, but if we have a reference, the data will stay in memory.


.. index:: 
	pair: Language Design; No Global Interpreter (VM) Lock - No GIL

No Global Interpreter (VM) Lock - No GIL
========================================

When we use threads in Ring applications, We don't have global interpreter (VM) lock (No GIL)

So threads can work in parallel and execute Ring instructions at the same time

This is better for threads and concurrency (More Faster!)

.. index:: 
	pair: Language Design; Fast Enough For Many Applications

Fast Enough For Many Applications
=================================

Ring is designed to be a simple, small and flexible language in the first place, but also it is fast enough for many applications.

Ring can do each of the next tasks in around 1 second using normal computers in the market during the last 5 years

(1) Compiling 100,000 lines of code
(2) Executing empty loop that count from 1 to 10,000,000
(3) Executing 1000 search operation using linear search in a list contains 100,000 items, trying to find the last item (The worst case)
(4) Creating list contains 1,000,000 items then summing all of the list items
(5) Adding 20,000 items to the ListWidget in GUI applications
(6) Adding 5,000 nodes to the TreeWidget in GUI applications
(7) Printing 10,000 messages to the terminal in Console applications

Also when we need more speed we can use C/C++ extensions! 

.. index:: 
	pair: Language Design; Ring Architecture

Ring Architecture
=================

We have the next architecture

(1) Ring Applications (Your Code)  - Written in Ring - See folder : ring/applications
(2) Ring Libraries (StdLib, WebLib, GameEngine, etc) - Written in Ring - See folder : ring/ringlibs
(3) Ring Extensions (RingAllegro, RingQt, etc) - Written in C/C++ (may include Ring code) - See folder : ring/extensions
(4) Ring Virtual Machine (Ring VM) - Written in C language
(5) Operating System (Current Platform) - (Windows, Linux, macOS, Android, etc)

The extensions are just dynamic libraries (DLL, So, Dylib)
You can update the extensions without the need to update your code.


Folder (ring/extensions/libdepwin) ====> C libraries used for building Ring Extensions (written in C) on Windows platform

Folder (ring/ringlibs)  ====> Ring libraries written in Ring itself (StdLib, WebLib, GameEngine, etc)

Folder (ring/visualsrc) ====> The Visual Source Code of the Ring Compiler & Ring VM developed using Programming Without Coding Technology (PWCT)

We use the term Ring Library ---> When the library code is written in Ring
We use the term Ring Extension ---> When the library code is Written in C or C++

.. index:: 
	pair: Language Design; Memory Management

Memory Management
=================

(1) When we call function, we get a new scope for this function, inside this scope we store variables.

Also we get Temp. memory for this function. Inside this temp. memory we store temp. lists

All of this will be deleted directly after the end of the function call (end of scope)

(2) In Ring to delete memory, you have the next options

2.1 Wait until the end of the function scope

2.2 Use the Assignment operator

2.3 Use callgc() function (delete temp. lists only)

(3) Ring Garbage Collector uses Escape Analysis and Reference Counting

In 90% of cases, the Escape Analysis is used so we don't waste time in running the garbage collector
We directly know what will be deleted and what will remain in the memory.

https://en.wikipedia.org/wiki/Escape_analysis

In 10% of cases (or less than that) Ring may use Reference Counting.

For example when we pass a list and sub list to a function
Ring will pass the lists by reference, but what will happens if we deleted the Parent List?
In this case, the Sub List will use reference counting, and when deleting the Parent List, it will stay in memory until the end of the function.

Remember that Ring encourage us to avoid using references, and the
Assignment Operator will copy lists by value, so Ring usage of reference counting is
very limited to special cases and in most cases the Escape Analysis is enough which is very fast.

Starting from Ring 1.9 we extended the Reference Counting support to Ring Extensions and low level C pointers.
So we don't have to care about using fclose() when we use fopen() for example. and the same for
other extensions like RingODBC, RingSQLite, RingMySQL, RingQt, etc.

All of the allocated resources will be cleaned by the Garbage Collector when we finish using it (when we lost the last reference).


.. index:: 
	pair: Language Design; Data Representation

Data Representation
===================

(1) In Ring, The String is just (Array of bytes)

Ring is 8-bit clean, Each character in the string is 8 bits (1 byte)

So these functions (Int2Bytes(), Float2Bytes() and Double2Bytes()) just return a string.

Also we can store binary data in strings

.. code-block:: ring

	mystring = read("myfile.exe")

(2) Remember this, when you think about variables

* Value ---> What we have (What we are storing in the computer memory as data) - Low Level Concept
* Type  ---> What we can do with what we have or how we do things with what we have (Just a Logical Concept)

Computer memory ----> Just store [Bytes] - Each byte is 8-bit - (Here we avoid the memory word concept)

These bytes could be grouped together when moved between the memory and the processor registers.
Here we have (The register size) and things like 32-bit and 64-bit for example.
Also we have the bytes order.

Programming Languages ----> Add Types (Just as a concept) to these bytes so we can determine what to do with them and how operations should be done.

And programming language could allow (Type Conversion) ---> Because the Type is a logical concept in most cases, What we really have is just data (Bytes, Bytes Count, Bytes Order, etc)

Ring Stings ----> You have these bytes (each byte is 8-bit) and Ring know the string size (stored as number in the String structure) 

So we don't check the NULL character or add it to the end of the string (Not Required)

All operations inside Ring VM, will check the Ring size and deal with the string as binary data (each character is 8-bit)

In the C language ---> The normal case is adding NULL character (\0) to the end of each string

And the string functions check this character, This is not suitable for binary data.

Signed vs Unsigned ---> Is a logical concept which is important when you do arithmetic operations on the data, but when storing the data, if you will include all of the (8-bits) and will not ignore any of them ---> Then don't care.

In Ring, don't think about these details, we are hiding it from you, so you can focus on your application and what you will do.

Think in C when you write C code which could be (based on need) low level code to have control on everything.
 ----> Good for performance and memory management

Think in Ring when you write Ring code which let you ignore a lot of details and concentrate only on the result
-----> Good for productivity and delivering software quickly

The good news (We can mix between Ring and C in our projects)


(3) The functions Int2Bytes(), Float2Bytes() and Double2Bytes()

These function take input as (Number) ---> Convert it to group of bytes based on the number type (int|float|double) ---> Then return a Ring string that contains these bytes

Int2Bytes() ---> Ring string (Group of bytes) and the string size = sizeof(int)

Float2Bytes() ---> Ring string (Group of bytes) and the string size = sizeof(float)

Double2Bytes() ---> Ring string (Group of bytes) and the string size = sizeof(double)

Example:

.. code-block:: ring

	? len( int2bytes(1) )
	? len( float2bytes(1) )
	? len( double2bytes(1) )

Output:

.. code-block:: none

	4
	4
	8

(4) Storing Numbers

When we use a number, Ring always use the (Double) data type for representing these numbers in memory.
This is important to know when we do arithmetic operations on numbers.

But when we convert the number to a String using "" + number  or using string(number) we get a string where each digit is represented in 1 byte (Not good idea for storage, but useful for string processing)

If you need the number to be represented in specific size (int|float|double) for storage then use bytes2int() , bytes2float() and bytes2double() when writing the data to binary files.

Ring Number (double) ----> int2bytes()  - will cast the number from double to int then return the bytes ----> 4 bytes (Ring String)

Ring Number (double) ----> float2bytes()  - will cast the number from double to float then return the bytes ----> 4 bytes (Ring String)

Ring Number (double) ----> double2bytes()  - will use the number (double) to return the bytes ----> 8 bytes (Ring String)
 
The (int) type is used only for internal Ring operations, but Ring applications|code will use only the (double) type for numbers.

(5) The Unsigned() Function

The function unsigned() expect the first and the second parameters as numbers

.. code-block:: ring

	unsigned(nNumber1,nNumber2,cOperator)

We can use the bytes2int() function to convert the bytes to a number

Example:

.. code-block:: ring 

	B = list(4)

	for k=1 to 4
	{  
		B[k]= Space(4)
		for kk=1 to 4 { B[k][kk]= char(60+4*k +kk) }
		? " B" +k +": " +B[k]
	}

	A12= Space(4)     A12= bytes2int(B[1]) ^ bytes2int(B[2])      		
	? "A12: " +string(A12)  
	A34= Space(4)     A34= bytes2int(B[3]) ^ bytes2int(B[4])      		
	? "A34: " +string(A34)
	A12= space(4)     A12= Unsigned(bytes2int(B[1]),bytes2int(B[2]),"^") 	
	? "unsigned A12: " +A12
	A34= space(4)     A34= Unsigned(bytes2int(B[3]),bytes2int(B[4]),"^") 	
	? "unsigned A34: " +A34

Output:

.. code-block:: none

	B1: ABCD
	B2: EFGH
	B3: IJKL
	B4: MNOP
	A12: 201589764
	A34: 470025220
	unsigned A12: 201589764
	unsigned A34: 470025220
