===========
Scope Rules
===========

In this chapter we will learn about scope rules and how ring find variables.

Also we will learn about conflicts and how to solve/avoid them.

These information are important once you start developing large applications with Ring
That uses Global variables, Classes and braces { } to access objects 

Three Scopes 
============

In Ring we have three scopes :-

(1) Public/Global Scope - Each variable you define in the statements part (before functions and classes)

(2) Object Scope - When you are inside an object (Inside class method or using { } to access the object )

(3) Local Scope - Related to functions and methods

Defining Variables and Variables Access
=======================================

* Ring uses lexical scoping, i.e. the scope of the variable is based on where 
we defined the variable.

* Inside braces {  } when you access an object - you still can access the global
scope and the local scope.

* After Class keyword and name , when you write variable names to define the class attributes
You still can access the global scope.

* Function Parameters are already defined in the local scope.

How Ring find the variable?
===========================

1 - Search First in the Local Scope 

if not found !

2 - Search in the Object Scope 

if not found !

3 - Search in the public scope

if not found ----> Runtime Error

if found  ----> Check if we can do optimization to avoid 
searching next time (Cache / Pointers for performance).

Conflict between global variables and Class Attributes
======================================================

Look at this example:

.. code-block:: none

	name = "test"
	o1 = new person
	see o1

	class person
		name
		address 
		phone

In the previous example we have aglobal variable called 'name'
inside the class person.

when we use the variable 'name', Ring will start the search operation and 
will try to find it.

if found ---> Use it

if not found ---> Define new attribute

But the variable name is a global variable, so it will be found and used!

We will not have the attribute name! added to the object. 

Solution (1) - Use the Main Function 

.. code-block:: none

	func main
		name = "test"
		o1 = new person
		see o1

	class person
		name
		address 
		phone

Solution Number (2) - Use special mark for global variable names like $

.. code-block:: none

	$name = "test"
	o1 = new person
	see o1

	class person
		name
		address 
		phone

Solution Number (3) - Use the AddAttribute() Method

.. code-block:: none

	name = "test"
	o1 = new person
	see o1

	class person
		AddAttribute(self,"name")
		address 
		phone

So what is the best solution to this conflict?

1 - Use the $ Mark 

2 - Optional : Try to avoid global variables and use the Main function 

In practice i do both of them.