===========
Scope Rules
===========

In this chapter we will learn about scope rules and how Ring find variables.

Also we will learn about conflicts and how to solve/avoid them.

The next information are important once you start developing large applications using Ring

These application may uses 

* Global variables (Try to avoid them)

* Classes (Object-Oriented)

* braces { } to access objects

* Declarative Programming

* Natural Programming

Three Scopes 
============

In Ring we have three scopes :-

(1) Public/Global Scope - Each variable you define in the statements part (before functions and classes)

(2) Object Scope - When you are inside an object (Inside class method or using { } to access the object )

(3) Local Scope - Related to functions and methods

Defining Variables and Variables Access
=======================================

(1) Ring uses lexical scoping, i.e. the scope of the variable is based on where we defined the variable.

(2) Inside braces {  } when you access an object, You still can access the global scope and the local scope.

(3) After the 'Class' keyword and the class name, when you write variable names to be defined as attributes, You still can access the global scope.

(4) Function Parameters are automatically defined in the local scope.

How Ring find the variable?
===========================

1 - Search First in the Local Scope 

if not found !

2 - Search in the Object Scope 

if not found !

3 - Search in the public scope

if not found ----> Runtime Error

if found  ----> Check if we can do optimization to avoid 
searching next time (Cache / Pointers for performance).

Conflict between global variables and Class Attributes
======================================================

Look at this example:

.. code-block:: none

	name = "test"
	o1 = new person
	see o1

	class person
		name
		address 
		phone

In the previous example we have a global variable called 'name'
inside the class person.

when we use the variable 'name', Ring will start the search operation and 
will try to find it.

if found ---> Use it

if not found ---> Define new attribute

But the variable name is a global variable, so it will be found and used!

We will not have the attribute name! added to the object. 

Solution (1) - Use the Main Function 

.. code-block:: none

	func main
		name = "test"
		o1 = new person
		see o1

	class person
		name
		address 
		phone

Solution Number (2) - Use special mark for global variable names like $

.. code-block:: none

	$name = "test"
	o1 = new person
	see o1

	class person
		name
		address 
		phone

Solution Number (3) - Use the AddAttribute() Method

.. code-block:: none

	name = "test"
	o1 = new person
	see o1

	class person
		AddAttribute(self,"name")
		address 
		phone

So what is the best solution to this conflict?

1 - Use the $ Mark 

2 - Optional : Try to avoid global variables and use the Main function 

In practice i do both of them.

conflict between class attribute and local variable 
===================================================

This conflict may happen when we access the object using braces

Example:

.. code-block:: none
 
	func main
		name = "nice"
		o1 = new person {name="mahmoud" address="Egypt"  phone = 000 }
		see o1

	class person 
		name
		address
		phone

In the previous example we have the local variable name.

The value of this variable will be set to "mahmoud" instead of the object attribute.

Solution : Just use Self 

.. code-block:: none

	func main
		name = "nice"
		o1 = new person {self.name="mahmoud" address="Egypt"  phone = 000 }
		see o1

	class person 
		name
		address
		phone