.. index:: 
	single: Scope Rules; Introduction

===========
Scope Rules
===========

In this chapter we will learn about scope rules and how Ring find variables.

Also we will learn about conflicts and how to solve/avoid them.

The next information are important once you start developing large applications using Ring

These application may uses 

* Global variables (Try to avoid them)

* Classes (Object-Oriented)

* braces { } to access objects

* Declarative Programming

* Natural Programming

.. index:: 
	pair: Scope Rules; Three Scopes

Three Scopes 
============

In Ring we have three scopes :-

(1) Public/Global Scope - Each variable you define in the statements part (before functions and classes)

(2) Object Scope - When you are inside an object (Inside class method or using { } to access the object )

(3) Local Scope - Related to functions and methods

.. index:: 
	pair: Scope Rules; Defining Variables and Variables Access

Defining Variables and Variables Access
=======================================

(1) Ring uses lexical scoping, i.e. the scope of the variable is based on where we defined the variable.

(2) Inside braces {  } when you access an object, You still can access the global scope and the local scope.

(3) After the 'Class' keyword and the class name, when you write variable names to be defined as attributes, You still can access the global scope.

In this region we have

	* Global Scope ----> The Global Scope
	* Object Scope ----> The Object Scope
	* Local Scope  ----> The Object Scope

.. note:: Since the local scope point also to the object scope in this region, we can use nested braces and still have access to the object scope through the local scope.

.. tip :: You can create windows and controls as attibutes by defining them in this region.
	

(4) Function Parameters are automatically defined in the local scope.

.. index:: 
	pair: Scope Rules; How Ring find the Variable?

How Ring find the variable?
===========================

1 - Search First in the Local Scope 

if not found !

2 - Search in the Object Scope 

if not found !

3 - Search in the public scope

if not found ----> Runtime Error

if found  ----> Check if we can do optimization to avoid 
searching next time (Cache / Pointers for performance).

.. index:: 
	pair: Scope Rules; Conflict between Global Variables and Class Attributes

Conflict between Global Variables and Class Attributes
======================================================

Look at this example:

.. code-block:: ring

	name = "test"
	o1 = new person
	see o1

	class person
		name
		address 
		phone

In the previous example we have a global variable called 'name'
inside the class person.

when we use the variable 'name', Ring will start the search operation and 
will try to find it.

if found ---> Use it

if not found ---> Define new attribute

But the variable name is a global variable, so it will be found and used!

We will not have the attribute name! added to the object. 

Solution (1) - Use the Main Function 

.. code-block:: ring

	func main
		name = "test"
		o1 = new person
		see o1

	class person
		name
		address 
		phone

Solution Number (2) - Use special mark for global variable names like $

.. code-block:: ring

	$name = "test"
	o1 = new person
	see o1

	class person
		name
		address 
		phone

Solution Number (3) - Use the AddAttribute() Method

.. code-block:: ring

	name = "test"
	o1 = new person
	see o1

	class person
		AddAttribute(self,"name")
		address 
		phone

So what is the best solution to this conflict?

1 - Use the $ Mark 

2 - Optional : Try to avoid global variables and use the Main function 

In practice i do both of them.

.. index:: 
	pair: Scope Rules; Conflict between Class Attributes and Local Variables

Conflict between Class Attributes and Local Variables
=====================================================

This conflict may happen when we access the object using braces

Example:

.. code-block:: ring
 
	func main
		name = "nice"
		o1 = new person {name="mahmoud" address="Egypt"  phone = 000 }
		see o1

	class person 
		name
		address
		phone

In the previous example we have the local variable name.

The value of this variable will be set to "mahmoud" instead of the object attribute.

Solution : Just use Self 

.. code-block:: ring

	func main
		name = "nice"
		o1 = new person {self.name="mahmoud" address="Egypt"  phone = 000 }
		see o1

	class person 
		name
		address
		phone

.. index:: 
	pair: Scope Rules; Using Braces to access objects inside Class Methods

Using Braces to access objects inside Class Methods
===================================================

Remember that we have Three scopes (Local Scope, Object Scope and Global Scope) and when we
are inside a class method, we expect that we have access to the object attributes and methods and
this is true until we use braces to access another object attributes and methods because in this case
our object scope will be switched to another object.


.. code-block:: ring

	new point { test() }

	class point
		x=10 y=20
		func test
			see x + nl + y + nl # works fine
			myobj = new otherclass {
				see name + nl
				see x + nl + y + nl # error !
			}

	class otherclass
		name = "test"

Output:

.. code-block:: none

	10
	20
	test

	Line 8 Error (R24) : Using uninitialized variable : x
	In method test() in file methodbraceerror.ring
	called from line 5  in file methodbraceerror.ring

Now what we will do to solve the previous problem?

The best solution : Don't Use Braces

.. code-block:: ring

	new point { test() }

	class point
		x=10 y=20
		func test
			see x + nl + y + nl  
			myobj = new otherclass 
			see myobj.name
			see x + nl + y + nl 			

	class otherclass
		name = "test"

Output:

.. code-block:: none

	10
	20
	test
	10
	20


Other Solution (May lead to other errors) : Copy the self object 

.. code-block:: ring

	new point { test() }

	class point
		x=10 y=20
		func test
			oSelf = self
			see x + nl + y + nl  
			myobj = new otherclass {
				see name + nl
				see oself.x + nl + oself.y + nl  
			}

	class otherclass
		name = "test"

Output:

.. code-block:: none

	10
	20
	test
	10
	20

Now look at this line

.. code-block:: ring

	oself = self

The problem with the previous line is that we will have a new copy from the object
Because in Ring the assignment operator copy lists and objects by value (not by reference).

When we access the new object attributes (reading) we don't have problems 

But if we modified the object attributes (Then we will modify the copy!).

.. note:: We can use braces again with the copy

.. code-block:: ring

	new point { test() }

	class point
		x=10 y=20
		func test
			oSelf = self
			see x + nl + y + nl  
			myobj = new otherclass {
				see name + nl
				oSelf {
					see x + nl + y + nl
				}
			}

	class otherclass
		name = "test"

In GUI application, we may create a class contains the window objects as attributes to be able 
to access the controls from different methods. Remember the previous information when you try to access
objects using braces inside methods because in this case you can't access the object attributes directly
and if you copied the self object you will work on a copy and the new controls that you create will be 
related to the copy and you can't access them.


.. index:: 
	pair: Scope Rules; Creating a Class for each Window in GUI applications

Creating a Class for each Window in GUI applications
====================================================

A good way for creating classes for windows is to define the window directly after the class name

In this area you can use nested braces without problems to define the window and the controls, and
they will be attributes that you can access from methods.

Example:

.. code-block:: ring

	Load "guilib.ring"

	new qApp 
	{
		$ObjectName = "oFirstWindow"
		oFirstWindow = new FirstWindow

		$ObjectName = "oSecondWindow"
		oSecondWindow = new SecondWindow

		exec()
	}

	Class FirstWindow

		win = new qWidget() {
			setgeometry(0,50,300,200)
			setWindowTitle("First Window")
			label1 = new qLabel(win)
			{
				setgeometry(10,10,300,30)
				setText("0")
			}
			btn1 = new qPushButton(win)
			{
				move(100,100)
				setText("Increment")
				setClickEvent($ObjectName+".increment()")
			}
			show()
		}	

		Func Increment
			label1 {
				setText( "" + ( 0 + text() + 1 ) )
			}


	Class SecondWindow

		win = new qWidget() {
			setgeometry(400,50,300,200)
			setWindowTitle("Second Window")
			label1 = new qLabel(win)
			{
				setgeometry(10,10,300,30)
				setText("0")
			}
			btn1 = new qPushButton(win)
			{
				move(100,100)
				setText("Decrement")
				setClickEvent($ObjectName+".decrement()")
			}
			show()
		}	

		Func Decrement
			label1 {
				setText( "" + ( 0 + text() - 1 ) )
			}